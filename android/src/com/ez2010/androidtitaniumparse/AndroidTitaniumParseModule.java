/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.ez2010.androidtitaniumparse;

import java.util.HashMap;
import java.util.List;

//import com.ndizazzo.parsemodule.ParseDataConversions;
//import com.ndizazzo.parsemodule.ParseSingleton;
import com.parse.Parse;
import com.parse.ParseObject;
import com.parse.FindCallback;
import com.parse.SaveCallback;
import com.parse.DeleteCallback;
import com.parse.ParseQuery;
import com.parse.ParseException;

import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.util.TiConvert;

@Kroll.module(name="AndroidTitaniumParse", id="com.ez2010.androidtitaniumparse")
public class AndroidTitaniumParseModule extends KrollModule
{
	private static ParseSingleton parseSingleton = null;

	// Standard Debugging variables
	private static final String LCAT = "AndroidTitaniumParseModule";
	private static final boolean DBG = TiConfig.LOGD;

	// You can define constants with @Kroll.constant, for example:
	// @Kroll.constant public static final String EXTERNAL_NAME = value;

	public AndroidTitaniumParseModule()
	{
		super();
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app)
	{
		Log.d(LCAT, "inside onAppCreate");
		
		// put module init code that needs to run when the application is created
		// Store a reference to the parse singleton now that the app is ready
		parseSingleton = ParseSingleton.Instance();

		// Obtain the application and client keys from the tiapp.xml file.
		// It must be stored there because of the way Android applications work,
		// we can't initialize the module during runtime because the application is
		// started when a push notification is received
		String propertyAppId = app.getAppProperties().getString(ParseSingleton.PROPERTY_APP_ID, "");
		String propertyClientKey = app.getAppProperties().getString(ParseSingleton.PROPERTY_CLIENT_KEY, "");
		String propertyServerUrl = app.getAppProperties().getString(ParseSingleton.PROPERTY_SERVER_URL, "");

		// Invoke the Parse SDK Initialize method
		//parseSingleton.InitializeParse(propertyAppId, propertyClientKey, app);
		parseSingleton.InitializeParseWithConfig(propertyAppId, propertyClientKey, propertyServerUrl, app);
	}

	@Kroll.method
	public void initParse(HashMap initOpts) {
		// This method stub doesn't actually initialize parse - it should be already started when the application starts
		// I'm putting this here so the application context is not null when the EnablePush method is run.
		parseSingleton.EnablePush(TiApplication.getInstance());
	}
	

	@Kroll.method
	public void initParseWithConfig(HashMap initOpts) { // This method is only for keeping the same interface with iOS version
	  initParse(initOpts);
	}
	
	// Methods
	@Kroll.method
    public int getStatusBarHeight() {
        int result = 0;
        int resourceId = this.getActivity().getResources().getIdentifier("status_bar_height", "dimen", "android");
        if (resourceId > 0) {
            result = this.getActivity().getResources().getDimensionPixelSize(resourceId);
        }
        return result;
    }

	@Kroll.method
	public void findObjects(String className, HashMap[] conditions, final KrollFunction applicationCallback) {
		FindCallback<ParseObject> parseCallback = new FindCallback<ParseObject>() {
			public void done(List<ParseObject> objects, ParseException e) {

				// General hash map to invoke the Titanium method with
				HashMap returnMap = new HashMap();
				if (objects != null && objects.size() > 0) {
					HashMap[] resultObjects = new HashMap[objects.size()];

					if (e == null) {
						int count = 0;
						for (ParseObject po : objects) {
							// Convert each object to a hash map to retain it's key/value properties
							HashMap objectMap = ParseDataConversions.ObjectToHashMap(po);
							resultObjects[count] = objectMap;
							++count;
						}

						returnMap.put("results", resultObjects);
					}
					else {
						// no objects were returned,
						returnMap.put("results", null);
					}

				}
				else {
					String errorMessage = "No objects found.";
					if (e != null) {
						errorMessage = e.toString();
					}
					returnMap.put("error", errorMessage);
				}

				applicationCallback.callAsync(getKrollObject(), returnMap);
			}
		};

		parseSingleton.FindDataObjects(className, conditions, parseCallback);
	}

	@Kroll.method
	public void createObject(String className, final HashMap data, final KrollFunction applicationCallback) {

		SaveCallback parseCallback = new SaveCallback() {
			public void done(ParseException e) {
				HashMap result = new HashMap();

				if (e == null) {
					result.put("object", data);
				} else {
					// There was an error
					result.put("error", e.toString());
				}

				if (applicationCallback != null) {
					applicationCallback.callAsync(getKrollObject(), result);
				}
			}
		};

		parseSingleton.CreateDataObject(className, data, parseCallback);
	}

	@Kroll.method
	public void updateObject(final HashMap data, final KrollFunction applicationCallback) {
		final ParseObject convertedObject = (ParseObject)ParseDataConversions.ConvertToParseObjectIfNecessary(data);
		SaveCallback parseCallback = new SaveCallback() {
			public void done(ParseException e) {
				HashMap result = new HashMap();
				HashMap returnObject = ParseDataConversions.ObjectToHashMap(convertedObject);
				if (e == null) {
					result.put("object", returnObject);
				} else {
					// There was an error
					result.put("error", e.toString());
				}

				if (applicationCallback != null) {
					applicationCallback.callAsync(getKrollObject(), result);
				}
			}
		};

		parseSingleton.UpdateDataObject(convertedObject, parseCallback);
	}

	@Kroll.method
	public void deleteObject(String className, String objectId, final KrollFunction applicationCallback) {
		DeleteCallback parseCallback = new DeleteCallback() {
			public void done(ParseException e) {
				HashMap result = new HashMap();
				if (e == null) {
					result.put("success", true);
				} else {
					result.put("error", e.toString());
				}

				applicationCallback.callAsync(getKrollObject(), result);
			}
		};

		parseSingleton.DeleteDataObject(className, objectId, parseCallback);
	}

	@Kroll.method
	public void registerForPush(String deviceToken, String channelName, KrollFunction applicationCallback) {

		// NOTE: deviceToken is not used, but in order to maintain call
		// compatibility with the iOS module, I'm leaving it as a parameter
		HashMap results = new HashMap();

		// The channel name can only match letters, numbers, dashes and underscores, and must start with a letter
		if (parseSingleton.ValidChannelName(channelName)) {
			parseSingleton.SubscribeToPushChannel(channelName);
			results.put("success", true);
		}
		else {
			// Invalid channel name
			results.put("success", false);
		}

		applicationCallback.callAsync(getKrollObject(), results);
	}

	@Kroll.method
	public void unsubscribeFromPush(String channelName, KrollFunction applicationCallback) {

		HashMap results = new HashMap();

		if (parseSingleton.ValidChannelName(channelName)) {
			parseSingleton.UnsubscribeFromPushChannel(channelName);
			results.put("success", true);
		}
		else {
			results.put("success", false);
		}

		applicationCallback.callAsync(getKrollObject(), results);
	}

	@Kroll.method
	public void registerForSinglePushChannel(String deviceToken, String channelName, KrollFunction applicationCallback) {
		// NOTE: deviceToken is not used, but in order to maintain call
		// compatibility with the iOS module, I'm leaving it as a parameter
		parseSingleton.SubscribeToSinglePushChannel(channelName);
		
		// This is just a fake call back function the saveEventually() function will be used and no need for callback
		HashMap results = new HashMap();
		results.put("success", true);
		applicationCallback.callAsync(getKrollObject(), results);
	}

	@Kroll.method
	public void registerForMultiplePushChannel(String deviceToken, String channels, KrollFunction applicationCallback) {
		Log.d(LCAT, "String String Callback");
		Log.d(LCAT, channels);
		
		String[] channelNames = channels.split(",");
		
		for ( String s: channelNames){
			Log.d(LCAT, s);
		}
		
		registerForMultiplePushChannel(deviceToken, channelNames, applicationCallback);

		// NOTE: deviceToken is not used, but in order to maintain call
		// compatibility with the iOS module, I'm leaving it as a parameter
		//parseSingleton.SubscribeToMultiplePushChannel(channelName);
		
		// This is just a fake call back function the saveEventually() function will be used and no need for callback
		//HashMap results = new HashMap();
		//results.put("success", true);
		//applicationCallback.callAsync(getKrollObject(), results);
	}

	@Kroll.method
	public void registerForMultiplePushChannel(String deviceToken, String[] channelNames, KrollFunction applicationCallback) {
		Log.d(LCAT, "String StringArray Callback");
		for ( String s: channelNames){
			Log.d(LCAT, s);
		}
		// NOTE: deviceToken is not used, but in order to maintain call
		// compatibility with the iOS module, I'm leaving it as a parameter
		parseSingleton.SubscribeToMultiplePushChannel(channelNames);
		
		// This is just a fake call back function the saveEventually() function will be used and no need for callback
		HashMap results = new HashMap();
		results.put("success", true);
		applicationCallback.callAsync(getKrollObject(), results);
	}

	@Kroll.method
	public void unsubscribeFromAllChannels(KrollFunction applicationCallback) {
		// NOTE: deviceToken is not used, but in order to maintain call
		// compatibility with the iOS module, I'm leaving it as a parameter
		parseSingleton.UnsubscribeFromAllChannels();
		
		// This is just a fake call back function the saveEventually() function will be used and no need for callback
		HashMap results = new HashMap();
		results.put("success", true);
		applicationCallback.callAsync(getKrollObject(), results);
	}
		
	@Kroll.method
	public void pushChannelList(KrollFunction applicationCallback) {
		HashMap results = new HashMap();

		List<String> channelList = parseSingleton.ChannelSubscriptionList();
		String[] channels = new String[channelList.size()];

		int count = 0;
		for (String channelName : channelList) {
			channels[count] = channelName;
			++count;
		}

		// Store the resulting string list under the 'channels' field for the Titanium App
		results.put("channels", channels);

		applicationCallback.callAsync(getKrollObject(), results);
	}

	// Methods
	@Kroll.method
	public String example()
	{
		Log.d(LCAT, "example called");
		return "hello world";
	}

	// Properties
	@Kroll.getProperty
	public String getExampleProp()
	{
		Log.d(LCAT, "get example property");
		return "hello world";
	}


	@Kroll.setProperty
	public void setExampleProp(String value) {
		Log.d(LCAT, "set example property: " + value);
	}

}

